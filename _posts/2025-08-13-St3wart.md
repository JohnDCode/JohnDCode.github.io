---
title: St3wart
description: A look at my Windows desktop and server vulnerability management tool, St3wart.
author: John
date: 2025-08-13 3:00:00 +0800
categories: [Projects, Cybersecurity]
tags: [C#, dotnet, Powershell, Bash, Windows, Cybersecurity]
media_subpath: '/assets/2025-08-13-St3wart'
---

The [source](https://github.com/JohnDCode/St3wartCLI) and [compiled binary](https://github.com/JohnDCode/JDA-St3wartCLI-Publish) for this project can be found on my [GitHub](https://github.com/JohnDCode).


### The Problem

Let’s say you are a newly hired IT administrator at a school. You’re responsible for managing hundreds, if not thousands, of devices. From student laptops to the desktop PCs in computer labs, it can quickly become overwhelming. To lighten the load, organizations often turn to centralized management systems such as Active Directory Domain Services (AD DS) for Windows or Jamf for Apple devices. These solutions are powerful, but they can be complex, platform-specific, and still leave gaps that require additional tools or expertise. In many environments, administrators struggle to achieve the balance between comprehensive management and practical day-to-day security.

When resources are stretched thin, this can lead to sloppy management. Too often — especially in smaller organizations or non-regulated sectors — cybersecurity is deprioritized until an incident forces attention. Budgets, competing priorities, and lack of staff expertise all contribute. This dynamic was one reason I chose not to pursue a career in cybersecurity.

I believe that if centralized cybersecurity management were simpler and more comprehensive, it would be easier for organizations to make it a priority. Unfortunately, the current mix of tools doesn’t always suffice.

Take the example of Active Directory. Policies are primarily enforced through Group Policy Objects (GPOs), which are extremely powerful for configuring standard Windows settings. However, GPOs don’t automatically cover every possible operating system or third-party application setting. To extend coverage, administrators often need to add vendor-supplied ADMX templates, craft custom registry policies, or adopt additional tools like Intune, SCCM/ConfigMgr, or PowerShell Desired State Configuration. While administrators can remotely query and report on applied policies using tools like Group Policy Management Console (GPMC) or gpresult, it’s not always straightforward to manage every setting an organization cares about.

![ADDS Diagram](/ADDSDiagram.png){: width="1117" height="556" }
_Diagram demonstrating Active Directory Domain Services policy management from [here](https://www.miniorange.com/blog/group-policy-in-active-directory/)_

Consider the case of application deployment. Enterprise tools exist to automate software rollout and configuration, but smaller IT teams — like those in many school districts — often lack the time, expertise, or vendor-supplied templates to reliably secure every new application. As a result, apps may be pushed out quickly to meet business demands, but their security configurations lag behind.

The conclusion is clear: we need something better. A way to easily manage policies and security configurations at scale, across diverse environments, without imposing overwhelming complexity. Enter St3wart.

<br />

### Background

For most of my time in high school, I aspired to be a penetration tester. I thought that (and still think) the idea of being hired and paid to exploit a company's network was extremely cool. One of the ways I pursued my study of cybersecurity was by competing in various cybersecurity competitions. The one that I dedicated the most time to was named CyberPatriot. 

During my time competing in CyberPatriot, I became extremely well versed in Windows security. Several times a year I was tasked with securing Windows machines, and as such, I was constantly seeking out the best ways to manage the policies and security of Windows systems. While I found good solutions, I decided to create my own suite of Windows tools and scripts designed to secure machines quickly and effectively in accordance with the CyberPatriot specific competition scenario.

After becoming known online as “St3wart”, I decided to call my scripts and tools St3wart. St3wart’s capabilities ranged from custom complex malware scanners written in C that used preconfigured baselines to identify malware in NTFS to powershell scripts designed to properly configure the Windows Firewall and Defender policies on the system in accordance with [CIS](https://www.cisecurity.org/cis-benchmarks-overview) and United States [DOD](https://www.cyber.mil/stigs) guidelines.

![St3wart Scripts](/St3wartCyPatGithub.png){: width="459" height="639" }
_My CyberPatriot scripts: St3wart (repo is private out of respect for competition rules)_

Following my final season in CyberPatriot and graduating high school, I couldn’t help but wonder if St3wart could be generalized. I had spent so long creating this set of scripts specifically for CyberPatriot, but what if I could create a way to generally secure Windows machines? This train of thought is what inspired this project.

<br />

### St3wart

St3wart is a lightweight, configurable, general purpose Windows security auditing tool. 

```
Note: The end vision for St3wart is for an IT Administrator to be able to remotely check for any
custom defined vulnerability on any one of their systems, and then automatically deploy proper
actions to secure the vulnerability if necessary. The current  implementation of St3wart is
specifically made for Windows and does not include remote scanning. Subsequent versions of
St3wart will implement these features.
```

The concept is simple. Administrators define checks to perform on systems in a json format. Then, they can test if the checks pass on systems, employ security measures to patch them, generate vulnerability reports based on findings, schedule periodic checks and security measures, and more. All through a portable, easy to use CLI tool.

<br />

### Demonstration

Lets take a look at how St3wart could be utilized to secure some basic vulnerabilities on a Windows machine.

When defining checks with St3wart, each check must have a "type". This type decides the mechanism in which St3wart will use to check for a finding. The three options are:

```
PowerShell
Registry
File
```

For this demonstration, we'll use one of each type of check. 

#### PowerShell Check - Log Size of Firewall

In the Windows Firewall, users have the option to specify the maximum size of the log file. This setting is independent for each of the three firewall profiles on the machine. CIS recommends that the Domain Firewall Profile log size be set to at least 16,384 KB (see CIS benchmarks and controls 6.4, 8.3, and 9.4). As such, we can say the following:

```
If the logsize of the Domain Profile on the Windows Firewall is less than 16,384 KB, there is a finding.
```

This logic is important and will shape how we structure our check.

We can retrieve this particular policy with the following PowerShell command;

```powershell
Get-NetFirewallProfile -Profile Domain | Select-Object -ExpandProperty LogMaxSizeKilobytes
```

```json
[	{
    	"ID": "TEST-001",
    	"Description": "Windows Firewall Domain Profile Log Size Configured",
    
    	"CheckType": "PowerShell",
    	"CheckCommand": "Get-NetFireWallProfile -Profile Domain | Select-Object -ExpandProperty LogMaxSizeKilobytes",
   	 	"FindData": "16384",
    	"Operator": "LessThan",
    	"SecureCommand": "Set-NetFirewallProfile -Profile Domain -LogMaxSizeKilobytes 16384"
  	}
]
```

Lets break this down line by line:

- **ID**: A unique string used to easily reference this check
- **Description**: A short description used to label the check
- **CheckType**: The type of the check, one of the three options given above.
- **CheckCommand**: A PowerShell check specific component, the PowerShell command ran to check for the presence of the vulnerability.
- **FindData & Operator**: The operator compares the output of the command with this find data to check for a finding. In this scenario, if the output of the command is less than the find data, 16,384 KB, the check fails and a finding has occurred. 
- **SecureCommand**: The PowerShell command to run to remediate the vulnerability. 

### Documentation
